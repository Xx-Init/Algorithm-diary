#include <bits/stdc++.h>
#define DEBUG cout << "---------- " << __LINE__ << " ----------" << endl;
#define endl "\n"
#define SZ(x) ((int)(x).size())
#define all(x) (x).begin(), (x).end()
#define count1_Binary(x) __builtin_popcountll(x)//求一个数二进制里有多少个1
#define smallest_1(x) __builtin_ffsll(x)//求最小的1在第几位
#define lowbit(x) ((x&(-x))) 
using namespace std;
using ll = long long;
using u64 = unsigned long long;
const ll inf = 0x7fffffffff;
const long long mod = 1e9+7;
const double Pi = acos(-1);
const int N = 5e4+6;
inline ll read(){ll x=0;char z;while((z=getchar())<48);do x=x*10+(z^48);while((z=getchar())>47);return x;}
//<head>

//离散化 双指针

//直接离散化后双指针扫描，先移动j指针知道所有id都有的区间，再移动i指针。

struct Node{
    ll X, ID;
    bool operator < (const Node& o) const {
        return X < o.X;
    }
}A[N];

ll B[N], num[N];

void solve(){
    int n;
    cin>> n;
    for(int i = 1; i <= n; i ++){
        cin>> A[i].X>> A[i].ID;
        B[i] = A[i].ID;
    }
    sort(B+1, B+1+n);
    int tot = unique(B+1, B+1+n)-B-1;
    for(int i = 1; i <= n; i ++){
        A[i].ID = lower_bound(B+1, B+1+tot, A[i].ID)-B-1;
    }
    sort(A+1, A+1+n);
    ll i = 1, j = 1, sum = 0, ans = inf;
    bool flag = false;
    while(j <= n){
        if(!num[A[j].ID]) sum ++;
        num[A[j ++].ID] ++;
        while(sum == tot){
            num[A[i].ID] --;
            if(!num[A[i ++].ID]) sum --;
            flag = true;
        }
        if(flag){
            flag = false;
            ans = min(ans, A[j-1].X-A[i-1].X);
        }
    }
    cout<< ans;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    solve();
    return 0;
}


